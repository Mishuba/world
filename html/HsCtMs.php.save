<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Go Live â€“ Mishuba</title>
    <style>
        body { font-family: sans-serif; background: #111; color: #eee; }
        input, textarea, select { width: 100%; margin: 5px 0; padding: 8px; }
        video { width: 100%; max-width: 640px; margin-top: 10px; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/webrtc-adapter/8.1.2/adapter.min.js" integrity="sha512-l40eBFtXx+ve5RryIELC3y6/OM6Nu89mLGQd7fg1C93tN6XrkC3supb+/YiD/Y+B8P37kdJjtG1MT1kOO2VzxA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
</head>
<body>
    <h1>Start Your Video Stream</h1>
    <button id="startButton">Start Streaming</button>

    <h2>Start Stream</h2>
    <form method="post">
        <input type="text" name="streamUrl" placeholder="RTMP URL" required>
        <button type="submit">Start</button>
    </form>

    <h2>Stop Stream</h2>
    <form id="destinationForm" method="post">
        <input type="text" name="stopStreamUrl" placeholder="RTMP URL" required>
        <button type="submit">Stop</button>
    </form>

    <h2>Post Metadata</h2>
    <form id="updateMetadataForm" method="post">
        <input type="text" name="title" placeholder="Title" required><br>
        <textarea name="description" placeholder="Description" required></textarea><br>
        <select name="platform" required>
            <option value="youtube">YouTube</option>
            <option value="twitch">Twitch</option>
            <option value="facebook">Facebook</option>
            <option value="instagram">Instagram</option>
            <option value="tumblr">Tumblr</option>
            <option value="pinterest">Pinterest</option>
            <option value="twitter">Twitter</option>
        </select><br>
        <button type="submit">Post Metadata</button>
    </form>

    <h1>Go Live with Mishuba</h1>
    <form id="streamForm">
        <input id="streamTitle" type="text" name="title" placeholder="Stream Title" required><br>
        <textarea id="streamDescription" name="description" placeholder="Description" required></textarea><br>
        <label>Platforms:</label><br>
        <input type="checkbox" name="platforms[]" value="twitch" checked> Twitch<br>
        <input type="checkbox" name="platforms[]" value="youtube"> YouTube<br>
        <input type="checkbox" name="platforms[]" value="facebook"> Facebook<br>
        <input type="checkbox" name="platforms[]" value="instagram"> Instagram<br><br>

        <label>Stream Keys:</label><br>
        <label>Stream Name: <input name="stream_name" required></label><br>
        Twitch: <input type="text" name="twitch_key"><br>
        <label>YouTube Key: <input name="youtube_key"></label><br>
        <label>YouTube Backup Key: <input name="youtube_backup_key"></label><br>
        Facebook: <input type="text" name="facebook_key"><br>
        Instagram (via Yellow Duck): <input type="text" name="instagram_key"><br><br>

        <button type="submit">Start Streaming</button>
    </form>

    <h2>Active Destinations</h2>
    <ul id="destinationList"></ul>

    <h1>WebRTC Setup with TURN and STUN Servers</h1>
    <video id="localVideo" autoplay muted></video>
    <video id="remoteVideo" autoplay></video>

    <video id="liveVideo" autoplay></video> 

<script>
    /*
    let socket = new WebSocket("wss://world.tsunamiflow.club/wss");
    let somesocket = new WebSocket("ws://world.tsunamiflow.club:8080);
    let securesocket = new WebSocket("wss://world.tsunamiflow.club:433);
    
    socket.onopen = () => {
    console.log('WebSocket connected');
};

// Handle incoming messages from the WebSocket server
socket.onmessage = (event) => {
    const message = JSON.parse(event.data);
    if (message.type === 'chat') {
        displayChatMessage(message.username, message.text);
    }
};

// Handle WebSocket connection errors
socket.onerror = (error) => {
    console.error('WebSocket Error: ', error);
};

// Handle WebSocket connection close
socket.onclose = () => {
    console.log('WebSocket connection closed');
};
*/
    let mediaRecorder;
    let videoStream;
    const form = document.getElementById('streamForm');
    const startButton = document.getElementById('startButton');
    const videoLocal = document.getElementById('localVideo');
    const $userComputer = navigator.userAgent;
    let whichCamera = true;

    const constraints = {
	audio: {
		deviceId: $userComputer,
		autoGainControl: {
			ideal: true
		},
		channelCount: {
			min: 2,
			ideal: 6,
			max: 12
		},
		echoCancellation: true,
		latency: {
			min: 0.003,
			ideal: 0.018,
			max: 0.036
		},
		//noiseSuppression: variable,
		sampleRate: {
			min: 8000,
			ideal: 96000,
			max: 192000
		},
		sampleSize: {
			min: 8,
			ideal: 16,
			max: 32
		},
	},
	image: {
		deviceId: $userComputer,
		whiteBalanceMode: {
			ideal: "none",
		},
		exposureMode: "none",
		focusMode: "none"
		//pointsOfInterest: { x: , y: ,},
		//colorTemperature:  //Integer
		//iso:  
		//brightness:  
		//contrast: 
		//saturation:
		//sharpness: 
		//focusDistance: 
		//zoom: 
		//torch: 
	},
	video: {
		deviceId: usersComputer,
		width: {
			min: 400,
			ideal: 600,
			max: 1280
		},
		height: {
			min: 400,
			ideal:600,
			max: 720
		},
		framerate: {
			min: 15,
			ideal: 30,
			max: 60
		},
		facingMode: whichCamera ? "" || "";
	}
    };

    function pushStreamToRTMP(blob) {
        // Replace with the actual RTMP URL where you want to push the stream
        const rtmpUrl = "rtmp://world.tsunamiflow.club/live/anything"; // Replace with your RTMP URL

        // Send the video stream (blob) to the RTMP server
        const formData = new FormData();
        formData.append('video', blob, 'video.webm'); // Send the video blob

        fetch(rtmpUrl, {
            method: 'POST',
            body: formData
        }).then(response => {
            if (response.ok) {
                console.log('Stream successfully pushed to RTMP server');
            } else {
                console.error('Error pushing stream to RTMP server');
            }
        }).catch(error => {
            console.error('Error pushing stream to RTMP server', error);
        });
    }

    // WebRTC connection setup with TURN and STUN servers
    function setupWebRTC() {
        const iceServers = [
            {
                urls: [
                    "turn:turn.cloudflare.com:3478?transport=udp",  // TURN server UDP
                    "turn:turn.cloudflare.com:3478?transport=tcp",  // TURN server TCP
                    "turns:turn.cloudflare.com:5349?transport=tcp",  // TURN server TLS
                    'turn:world.tsunamiflow.club:3478'
                ],
                username: "TsunamiCommunity",  // Replace with your TURN server community name
                credential: "1adac78d1efe9dc1d3315af466fadf0b62e0a1ab565bf3aaca88b26718ac2a04"  // Your TURN API Token
            },
            {
                urls: "stun:stun.cloudflare.com:3478",  // STUN server URL
                urls: 'stun:world.tsunamiflow.club:3478'
            }
        ];

        // Create WebRTC Peer Connection
        const peerConnection = new RTCPeerConnection({
            iceServers: iceServers
        });

        // When a new ICE candidate is found, log it or send it to the remote peer
        peerConnection.onicecandidate = (event) => {
            if (event.candidate) {
                console.log("New ICE Candidate: ", event.candidate);
            }
        };

        // When the connection state changes (e.g., connected, disconnected), log the state
        peerConnection.onconnectionstatechange = (event) => {
            console.log("Connection State Change: ", peerConnection.connectionState);
        };

        // Handle incoming media streams from the remote peer
        peerConnection.ontrack = (event) => {
            const remoteStream = event.streams[0];
            const remoteVideo = document.getElementById("remoteVideo");
            remoteVideo.srcObject = remoteStream;
        };

        // Local media stream (e.g., video and audio from the user's webcam)
        async function startLocalStream() {
            try {
                const localStream = await navigator.mediaDevices.getUserMedia({constraints});
                const localVideo = document.getElementById("localVideo");
                localVideo.srcObject = localStream;

                // Add local tracks to the peer connection
                localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));
            } catch (error) {
                console.error("Error accessing local media: ", error);
            }
        }

        // Call this function to start the WebRTC process
        async function createOffer() {
            await startLocalStream();

            // Create an offer to connect to the remote peer
            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);

            console.log("Sending offer: ", offer);
        }

        createOffer();
    }

    startButton.addEventListener('click', async () => {
        try {
            // Access webcam or screen
            videoStream = await navigator.mediaDevices.getUserMedia(constraints);
            videoLocal.srcObject = videoStream;

            // Create MediaRecorder from video stream
            mediaRecorder = new MediaRecorder(videoStream);

            // Handle data available
            mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    const videoBlob = event.data;
                    const videoUrl = URL.createObjectURL(videoBlob);

                    // Send the recorded video to your RTMP server
                    pushStreamToRTMP(videoBlob);
                }
            };

            // Start recording
            mediaRecorder.start(1000); // Collects chunks every second

            console.log('Streaming started!');
        } catch (err) {
            console.error('Error accessing webcam: ', err);
        }
    });

    const video = document.getElementById('liveVideo');

    document.getElementById('updateMetadataForm').addEventListener('submit', async e => {
        e.preventDefault();
        const title = document.getElementById('streamTitle').value;
        const description = document.getElementById('streamDescription').value;
        const platforms = Array.from(document.querySelectorAll('input[name="platform"]:checked')).map(el => el.value);

        await fetch('', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ title, description, platforms })
        });
        alert('Metadata updated!');
    });

    document.getElementById('destinationForm').addEventListener('submit', async e => {
        e.preventDefault();
        const newDestination = document.getElementById('newDestination').value;

        const formData = new URLSearchParams();
        formData.append('new_destination', newDestination);

        await fetch('', {
            method: 'POST',
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            body: formData
        });
        console.log('New RTMP destination added!');
        loadDestinations();
    });

    async function loadDestinations() {
        const res = await fetch('');
        const destinations = await res.json();
        const list = document.getElementById('destinationList');
        list.innerHTML = '';
        destinations.forEach(dest => {
            const li = document.createElement('li');
            li.textContent = dest.cmd;
            list.appendChild(li);
        });
    }

    loadDestinations();
    
    const videoRemote = document.getElementById('remoteVideo');
    const videoSrc = 'https://world.tsunamiflow.club/hls/anything.m3u8';

    if (Hls.isSupported()) {
        const hls = new Hls();
        hls.loadSource(videoSrc);
        hls.attachMedia(videoRemote);
    } else if (videoRemote.canPlayType('application/vnd.apple.mpegurl')) {
        videoRemote.src = videoSrc;
    }
</script>
</body>
</html>
